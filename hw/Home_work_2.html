<html>
    <head>
        <link type="text/css" rel="stylesheet" href="stile2.css">
        <div class="content">
            <div class="col1">
                <a href="Home_work_2.html">Home page</a>
            </div>
            <div class="col2">
                <a href="Contacts.html">Contacts</a>
            </div>
            <div class="col3">
                <a href="Add.html">Additional Information</a>
            </div>
            <div class="col4">
                <a href="Profile.html">Profile</a>
            </div>
            <div class="col5">
                <a href="News.html">News</a>
            </div>
            <div class="col6">
                <a href="Sittings.html">Sittings</a>
            </div>
        </div>
    </head>
    <body>
        <link type="text/css" rel="stylesheet" href="stile2.css">
        <h1>
            PHP
            <br>
            <br>
        </h1>
        <h2>
            Много текста про практику работы с PHPUnit/DbUnit
        </h2>
        <p>
            Доброго времени суток, друзья! 
            Хочу поделиться опытом по борьбе с PHPUnit/DbUnit в связке с MySQL. Далее небольшая предыстория.
        </p>
        <h2>
            Краткая предыстория
        </h2>
        <p>
            В процессе написания одного веб-приложения возникла необходимость тестировать код на PHP, интенсивно взаимодействующий с БД MySQL. В проекте в качестве фреймворка модульного тестирования использовался порт xUnit — PHPUnit. В результате было принято решение писать тесты для модулей, непосредственно взаимодействующих с базой, подцепив плагин PHPUnit/DbUnit. Дальше я расскажу о тех трудностях, которые возникли при написании тестов и о том, каким способом я их преодолел. В ответ же хотелось бы получить комментарии знающих людей относительно корректности моих решений.
        </p>
        <h2>
            Как работает DbUnit
        </h2>
        <p>
            Подпункт предназначен для тех, кто не знаком с методикой тестирования с использованием PHPUnit и/или DbUnit. Кому не интересно, смело можно переходить к следующему.
            
            Далее по тексту:
            тестовый класс — класс, содержащий код модульных тестов, наследник любой из реализаций PHPUnit::TestCase;
            тестируемый класс — класс, который необходимо протестировать.
            Так как подпункт для начинающих, то для начала будет рассмотрена процедура модульного тестирования обычных классов PHP, а потом описаны отличия при тестировании кода, взаимодействующего с БД.
        </p>
        <h2>
            Тестирование обычных классов PHP
        </h2>
        <p>
            Чтобы протестировать класс, написанный на PHP, с использованием фреймворка PHPUnit, необходимо создать тестовый класс, расширяющий базовый класс PHPUnit_Framework_TestCase. Затем создать в этом классе публичные методы, начинающиеся со слова test (если создать метод, который будет называться по-другому, он не будет автоматически вызван при прогоне тестов), и поместить в них код, выполняющий действия с объектами тестируемого класса и проверяющий результат. На этом можно закончить и скормить полученный класс phpunit, который, в свою очередь, последовательно вызовет все тестовые методы и любезно предоставит отчет об их работе. Однако в большинстве случаев в каждом из тестовых методов будет повторяющийся код, подготавливающий систему для работы с тестируемым объектом. Для того, чтобы избежать дублирования кода, в классе PHPUnit_Framework_TestCase созданы защищенные методы setUp и tearDown, имеющие пустую реализацию. Эти методы вызываются перед и после запуска очередного тестового метода соответственно и служат для подготовки системы к выполнению тестовых действий и очистки ее после завершения каждого теста. В тестовом классе, расширяющем PHPUnit_Framework_TestCase, можно переопределить эти методы и поместить повторяющийся ранее в каждом тестовом методе код в них. В результате последовательность вызова методов при прогонке тестов будет следующая:
        </p>
        <p>
            setUp()       {/* Установили систему в нужное состояние */}<br>
            testMethod1() {/* протестировали метод 1 класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
            setUp()       {/* Установили систему в нужное состояние */}<br>
            testMethod2() {/* протестировали метод 2 класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
            …<br>
            setUp()       {/* Установили систему в нужное состояние */}<br>
            testMethodN() {/* протестировали метод N класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
        </p>
        <h2>
            Тестирование кода PHP, взаимодействующего с БД
        </h2>
        <p>
            Процесс написания тестов для кода, взаимодействующего с БД, практически не отличается от процедуры тестирования обычных классов PHP. Сначала необходимо создать тестовый класс, наследующий PHPUnit_Extensions_Database_TestCase (класс PHPUnit_Extensions_Database_TestCase сам при этом наследует PHPUnit_Framework_TestCase), который будет содержать тесты для методов тестируемого класса. Затем создать тестовые методы, начинающиеся с префикса test, а потом скормить этот код phpunit с указанием имени тестового класса. Отличия заключаются лишь в том, что в тестовом классе обязательно необходимо реализовать два публичных метода — getConnection() и getDataSet(). Первый метод необходим для того, чтобы научить DbUnit работать с БД (придется использовать PDO), а второй для того, чтобы сообщить фреймворку, в какое состояние переводить базу данных перед выполнением очередного теста. Под DataSet в терминологии DbUnit понимается набор из одной или более таблиц.
            Как говорилось выше, перед выполнением очередного теста (представленного методом в тестовом классе), PHPUnit вызывает специальный метод setUp(), чтобы сэмулировать среду выполнения для объекта тестируемого класса. В случае DbUnit реализация по умолчанию метода setUp() уже не пустая. Если говорить в общих чертах, то внутри метода setUp() будет создан некий объект databaseTester, который, используя определенный нами метод getConnection(), переведет базу в состояние, представленное набором таблиц (DataSet`ом), получаемым при вызове метода getDataSet(). Если вы были внимательны, то реализация метода getDataSet() также должна предоставляться тестовым классом, т.е. нами. В результате получим похожую последовательность вызовов
        </p>
        <p>
            setUp()       {/* Установили БД в соответствии с данными, получаемыми от метода getDataSet() */}<br>
            testMethod1() {/* протестировали метод 1 класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
            setUp()       {/* Установили БД в соответствии с данными, получаемыми от метода getDataSet() */}<br>
            testMethod2() {/* протестировали метод 2 класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
            …<br>
            setUp()       {/* Установили БД в соответствии с данными, получаемыми от метода getDataSet() */}<br>
            testMethodN() {/* протестировали метод N класса */}<br>
            tearDown()    {/* Очистили систему */}<br>
        </p>
        <div class="footer">
            ivanivanov@mail.ru +7 (926) 876 54 32
        </div>
    </body>
</html>